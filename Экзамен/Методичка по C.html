<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C++ Экзамен</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="экзамен-углубленный-cc">Экзамен: “Углубленный C/C++”</h1>
<h2 id="программа-состоящая-из-нескольких-файлов">1. Программа, состоящая из нескольких файлов</h2>
<p>Главная причина: упрощение разработки программы.</p>
<p><strong>Зачем программу разбивают на части?</strong></p>
<ul>
<li>Небольшую часть проще понять.</li>
<li>Небольшую часть проще тестировать и отлаживать.</li>
<li>Разные части могут разрабатывать разные люди.</li>
<li>Отдельные части проще использовать в новых проектах.</li>
</ul>
<p>Разбивают программу на <em>функции</em> и <em>файлы</em>.</p>
<h3 id="компиляция-и-линковка">Компиляция и линковка</h3>
<p>Компиляция: main.c -&gt; main.o, util.c -&gt; util.o (объектный файл)<br>
Линковка: main.o util.o -&gt; main.exe<br>
<strong>Объектный файл</strong> представляет из себя бинарник, в котором имена функций еще не заменены адресами.<br>
<strong>Линкер</strong> должен склеить файлы вместе и заменить вызовы функции по имени на вызовы по адресу (процессор понимает только числа - адреса).<br>
<strong>Особенность компиляции:</strong> <em>файлы компилируются независимо друг от друга, соответсвенно, при компиляции один файл не знает никакой информации о другом! После этого они линкуются</em><br>
<strong>Преимущество такого подхода:</strong> программисту не нужно компилировать весь проект с нуля при изменении только одного файла. Например: изменения были в util.c, соответсвенно, перекомпилировали util.c -&gt; util.o, далее опять слинковали util.o main.o (main.o заново не компилировался) и получили новый исходник.</p>
<blockquote>
<p>Операция компиляции вычислительно сложнее (подбор команд, регистров, ячеек памяти), чем линковка (два прохода по исполняемому файлу: 1. составить таблицу имя функции &lt;–&gt; адрес; 2. заменить вызовы по имена на адрес из таблицы.)</p>
</blockquote>
<h3 id="заголовочные-файлы">Заголовочные файлы</h3>
<p><strong>Типовые ошибки линковки</strong></p>
<ul>
<li>undefined refernce (есть вызов, нет функции)</li>
<li>multiple definition (несколько функций с одинаковым именем)<br>
Компилятор языка C не помещает в объектный код информацию (количество, типы) о параметрах функции, а линкер не проверяет соответствие между вызовом и определением функции (definition).</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token comment">//main.c</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">3</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token punctuation">}</span>

<span class="token number">1</span> <span class="token comment">//util.c</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// definition</span>
<span class="token number">3</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Ошибка времени выполнения: sum возьмет из памяти произвольное<br>
число в качестве второго параметра.</p>
</blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token comment">//main.c</span>
<span class="token number">2</span> #include <span class="token string">"util.h"</span>
<span class="token number">3</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">4</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// compilation error</span>
<span class="token number">7</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token punctuation">}</span>

<span class="token number">1</span> <span class="token comment">//util.c</span>
<span class="token number">2</span> #include <span class="token string">"util.h"</span>
<span class="token number">3</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// definition</span>
<span class="token number">4</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token punctuation">}</span>

<span class="token number">1</span> <span class="token comment">//util.h</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// declaration</span>
</code></pre>
<blockquote>
<p>Решение: поместить объявление (declaration) функции в<br>
заголовочный файл</p>
</blockquote>
<ul>
<li>Директива include вставляет содержимое файла util.h в исходный код.</li>
<li>Результат: на стадии компиляции будут выявлены несоответствия между объявлением и определением, между вызовом и объявлением =&gt; между вызовом и определением.</li>
</ul>
<blockquote>
<p>Программа –&gt; [Препроцессор] –&gt; [Компилятор] –&gt; [Ассемблер] –&gt; Объектный файл</p>
</blockquote>
<h3 id="препроцессор">Препроцессор</h3>
<p>Простая программа, задача которой заключается в том, чтобы вставить или заменить какие-либо строчки в коде.</p>
<blockquote>
<p>#include  (вставляет содержимое файла в код) выполняется препроцессором</p>
</blockquote>
<p><strong>#define</strong> - определяет последовательность символов, которой будет заменяться индетификатор (просто взамен одного подставляет другое). Также выполняется препроцессором.</p>
<blockquote>
<p><em>#define имя_макроса последовательность_символов</em></p>
</blockquote>
<blockquote>
<p>Пример:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">define</span> TRUE 1  </span>
<span class="token macro property">#<span class="token directive keyword">define</span> FALSE 0  </span>
</code></pre>
<p>В результате, если компилятор обнаружит в тексте программы TRUE или FALSE, то он заменит их на 1 и 0 соответственно. Например, следующая строка выводит на экран «0 1 2»:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span> TRUE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>#ifdef, #ifndef, #else, #endif</strong><br>
Директивы условной компиляции препроцессора позволяют компилировать или пропускать часть программы в зависимости от выполнения некоторого условия.</p>
<p>Условие может принимать одну из описываемых ниже форм.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">ifdef</span> identifier  </span>
<span class="token comment">// код, находящийся здесь, компилируется, если identifier уже был определен для препроцессора в команде #define.  </span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> identifier  </span>
<span class="token comment">// код, находящийся здесь, компилируется, если identifier в данный момент не определен командой препроцессора #define.  </span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre>
<p>За любой из команд условной компиляции может следовать произвольное число строк, содержащих, возможно, команду вида #else и заканчивающихся #endif. Если проверяемое условие справедливо, то строки между #else и #endif игнорируются. Если же проверяемое условие не выполняется, то игнорируются все строки между проверкой и командой #else, а если ее нет, то командой #endif.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token comment">// util.h</span>
<span class="token macro property">#<span class="token directive keyword">ifndef</span> UTIL_H_</span>
<span class="token macro property">#<span class="token directive keyword">define</span> UTIL_H_</span>
<span class="token comment">// ...</span>
<span class="token macro property">#<span class="token directive keyword">endif</span> </span>
</code></pre>
<h3 id="утилита-make">Утилита make</h3>
<p><strong>make</strong> — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:</p>
<ol>
<li>целями (то, что данное правило делает);</li>
<li>реквизитами (то, что необходимо для выполнения правила и получения целей);</li>
<li>командами (выполняющими данные преобразования).</li>
</ol>
<p>В общем виде синтаксис makefile можно представить так:</p>
<pre><code># Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
&lt;цели&gt;: &lt;реквизиты&gt;
	&lt;команда #1&gt;
	...
	&lt;команда #n&gt;
</code></pre>
<h2 id="указатели-массивы">2. Указатели, массивы</h2>
<p><strong>Указатель</strong> - число, адрес (т.е. смещение от начала соответствующего элемента в памяти)<br>
<em><em>int</em> p</em>* - указатель на ячейку, в которой хранится int (в ‘p’ будет хранится адрес)</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// &amp; -- взять адрес a</span>
<span class="token number">3</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// взять значение по адресу p (разыменовать)</span>
<span class="token number">4</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// вывести адрес</span>
</code></pre>
<h3 id="арифметика-указателей">Арифметика указателей</h3>
<p>Сдвиг зависит от типа объектов, на который указывает указатель</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> array<span class="token punctuation">;</span> <span class="token comment">// pi = &amp;array[0]</span>
<span class="token number">4</span> <span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> str<span class="token punctuation">;</span> <span class="token comment">// pc = &amp;str[0]</span>
<span class="token number">5</span> pi <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// сдвиг адреса на sizeof(int)</span>
<span class="token number">6</span> pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// сдвиг адреса на sizeof(char)</span>

array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">[</span>array<span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token number">1</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>array <span class="token operator">+</span> i<span class="token punctuation">)</span>
<span class="token number">2</span> i<span class="token punctuation">[</span>array<span class="token punctuation">]</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>i <span class="token operator">+</span> array<span class="token punctuation">)</span>
</code></pre>
<h3 id="применение-указателей">Применение указателей</h3>
<h4 id="возврат-нескольких-значений-из-функции">1. Возврат нескольких значений из функции</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>pa<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>pb<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">double</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token operator">*</span>pb <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token punctuation">}</span>
<span class="token number">6</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">7</span> <span class="token keyword">double</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token punctuation">}</span>
</code></pre>
<h4 id="передать-большой-объект-в-функцию-и-не-копировать-его">2. Передать большой объект в функцию и не копировать его</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="оптимизация-кода">3. Оптимизация кода</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token comment">// Не оптимизированный код</span>
<span class="token keyword">int</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
		<span class="token operator">++</span>len<span class="token punctuation">;</span>
	<span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>*<em>ptr[len] -&gt; <em>(ptr + len)</em></em><br>
Соответсвенно, в данной реализации будет 2n операций сложений</p>
</blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token comment">// Не оптимизированный код</span>
<span class="token keyword">int</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
		<span class="token operator">++</span>p<span class="token punctuation">;</span>
	<span class="token keyword">return</span> p <span class="token operator">-</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Здесь уже будет n + 1 арифметических операций</p>
</blockquote>
<h3 id="ключевое-слово-const">Ключевое слово const</h3>
<p><strong>Константы</strong> — фиксированные величины, которые не изменяются во время выполнения программы. Эти фиксированные величины также называются <strong>литералами</strong>.</p>
<h4 id="const-у-переменной">const у переменной</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">float</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span>
</code></pre>
<ul>
<li>Компилятор проверит, чтобы мы не изменили число pi.</li>
<li>Дает больше информации программисту, читающему или используещему этот код.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">print_hex</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Программист подчеркнул, что функция не изменит параметр внутри себя</p>
</blockquote>
<h4 id="const-у-указателя">const у указателя</h4>
<p>const защищает то, что <strong>перед</strong> ним.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"bye"</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token number">4</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment">// compilation error</span>
<span class="token number">5</span> p1 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token number">6</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token number">7</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token number">8</span> p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">// compilation error</span>
<span class="token number">9</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
Но можно и так<span class="token punctuation">:</span>
<span class="token number">1</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p1<span class="token punctuation">;</span> <span class="token comment">// equal to char const * p1;</span>
</code></pre>
<h2 id="три-вида-памяти.-работа-с-кучей-на-c.">3. Три вида памяти. Работа с кучей на C.</h2>
<h3 id="стек-stack">Стек (stack)</h3>
<ul>
<li>Локальные переменные функций, параметры функций.</li>
<li>Код для выделения и освобождения генерирует компилятор.</li>
<li>Выделяется при “входе” в функцию, освобождается при “выходе” из функции.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">int</span> s <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token punctuation">}</span>
<span class="token number">5</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">6</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token punctuation">}</span>
</code></pre>
<p>Stack, растет вниз ↓(например, 10 Mb)</p>

<table>
<thead>
<tr>
<th><strong>Кадр main</strong></th>
<th><strong>c, d, e, RV, RA</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Кадр sum</strong></td>
<td><strong>a, c, s, RV, RA</strong></td>
</tr>
</tbody>
</table><ul>
<li>RV - return value (возвращаемое значение)</li>
<li>RA - return adsress (на какой адрес вернуться в main после окончания sum)</li>
</ul>
<h4 id="вычислительная-сложность">Вычислительная сложность</h4>
<p>Вошли в функцию — выделили кадр (frame), вышли из функции — освободили кадр</p>
<ul>
<li>В процессоре есть регистр (например, sp), который хранит адрес “головы” стека</li>
<li>Выделение кадра — уменьшение регистра на размер кадра, освобождение — увеличение (быстрые операции)</li>
<li>Код, который расчитывает размер кадра и меняет sp, генерирует компилятор</li>
<li>Выделение локальной переменной — это очень быстро, происходит один раз на функцию</li>
</ul>
<h4 id="проблемы-рекурсии">Проблемы рекурсии</h4>
<ul>
<li>Возможно большое кол-во вызовов, что приведет к переполнению стека.</li>
<li>Зачастую можно переписать циклом без потери красоты решения.</li>
</ul>
<h3 id="глобальнаястатическая-память-static-variables">Глобальная/статическая память (static variables)</h3>
<ul>
<li>Глобальные переменные (вне функций), статические переменные (static)</li>
<li>Код для выделение и освобождения генерируется компилятором.</li>
<li>Выделяется при загрузке в память, освобождается при завершении программы.</li>
<li>Глобальные инициализируются в каком-то (неизвестном) порядке, статические при заходе в функцию.</li>
</ul>
<p>Слово static имеет два разных смысла в зависимости от контекста.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Глобальная переменная (видна во всех файлах)</span>
<span class="token number">2</span>
<span class="token number">3</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Глобальная переменная</span>
<span class="token number">4</span> <span class="token comment">// (видна только в этом файле)</span>
<span class="token number">5</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">6</span> <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Статическая переменная</span>
<span class="token number">7</span> <span class="token comment">// (видна только в функции)</span>
<span class="token number">8</span> <span class="token punctuation">}</span>
</code></pre>
<ul>
<li>К переменной a можно обращаться из других файлов при помощи extern.</li>
<li>Переменная b не будет видна из других файлов даже если есть extern.</li>
<li>Переменную c вообще не имеет смысла видеть в других файлах.</li>
</ul>
<h4 id="глобальные-переменные.-несколько-файлов">Глобальные переменные. Несколько файлов</h4>
<pre class=" language-c"><code class="prism  language-c">  <span class="token number">1</span><span class="token punctuation">.</span>h
<span class="token number">1</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> last_rnd<span class="token punctuation">;</span>

  <span class="token number">1</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> <span class="token keyword">int</span> last_rnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//выделение памяти</span>
<span class="token number">2</span> <span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">3</span> last_rnd <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//текущее время</span>
<span class="token number">4</span> <span class="token punctuation">}</span>

  <span class="token number">2</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> #include <span class="token string">"1.h"</span>
<span class="token number">2</span> <span class="token comment">//extern -&gt; выделение памяти происходит в другом месте</span>
<span class="token number">3</span> <span class="token comment">// (также знаем тип переменной)</span>
<span class="token number">4</span> <span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">5</span> last_rnd <span class="token operator">=</span> <span class="token punctuation">(</span>lst_rnd <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> <span class="token number">113</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">43</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">return</span> last_rnd<span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Данный код не скомпилируется, т.к. переменная определена дважды</p>
<pre class=" language-c"><code class="prism  language-c">  <span class="token number">1</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> <span class="token keyword">int</span> last_rnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">3</span> last_rnd <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//текущее время</span>
<span class="token number">4</span> <span class="token punctuation">}</span>

  <span class="token number">2</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> <span class="token keyword">int</span> last_rnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">3</span> last_rnd <span class="token operator">=</span> <span class="token punctuation">(</span>lst_rnd <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> <span class="token number">113</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">43</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">return</span> last_rnd<span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token punctuation">}</span>
</code></pre>
</blockquote>
<h4 id="вычислительная-сложность-1">Вычислительная сложность</h4>
<ul>
<li>В заголовке двоичного исполняемого файла написано, сколько static variables ему требуется</li>
<li>Память выделяется “непрерывным куском”при загрузке программы. Освобождается — когда программа заканчивает работу.</li>
<li>Выделение происходит быстро.</li>
</ul>
<h4 id="почему-лучше-избегать-глобальных-переменных">Почему лучше избегать глобальных переменных</h4>
<ul>
<li>Потенциальный конфликт имен (несколько программистов в<br>
разных файлах назвали разные переменные одинаково —&gt;<br>
конфликт на линковке)</li>
<li>Трудно анализировать программу (сложнее следить за всеми<br>
участками кода, в которых меняется перменная)</li>
<li>Неизвестно, в каком порядке инициализируются разные файлы:</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token comment">// a.cpp</span>
<span class="token number">2</span> <span class="token keyword">int</span> ten <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// Первый, потому что константа</span>
<span class="token number">3</span> <span class="token keyword">int</span> x <span class="token operator">=</span> ten<span class="token punctuation">;</span> <span class="token comment">// Второй или третий</span>
<span class="token number">4</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token number">5</span> <span class="token comment">// b.cpp</span>
<span class="token number">6</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Второй или третий</span>
</code></pre>
<h3 id="куча-heap">Куча (heap)</h3>
<ul>
<li>Код для выделения и освобождения пишет программист</li>
</ul>
<p>Область памяти, в которой можно хранить различные данные. Главной особенностью является то, что управляет этой областью сам программист, а не компилятор.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> #include <span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token number">2</span>
<span class="token number">3</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000000</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// NULL в C, nullptr в C++. Старый код - 0.</span>
<span class="token number">5</span> <span class="token comment">/* not enough memory */</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
<span class="token number">7</span> <span class="token comment">// if (!p) { ... } // Альтернативный вариант</span>
<span class="token number">8</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p<span class="token punctuation">[</span><span class="token number">13000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">10</span> <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>Временем жизни управляет программист</li>
<li>Функция malloc обращается к операционной системе с просьбой выделить место (“непрерывный кусок”) в куче и, если ОС выделяет это место, возвращает укзатель на начало области (иначе — 0).</li>
<li>Функция free освобождает память</li>
<li>Нет ограничений по размеру как у стека и глобальных переменных (ограничена размером свободной памяти)</li>
</ul>
<h4 id="отличия-от-стека-и-глобальных-переменных">Отличия от стека и глобальных переменных</h4>
<ul>
<li>Размер массива выясняется во время выполнения (ввел<br>
пользователь, считали из файла)</li>
<li>На стеке и у глобальных переменных размер должен быть<br>
известен во время компиляции</li>
</ul>
<h4 id="возможные-ошибки">Возможные ошибки</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000000</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000000</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token comment">// Или: p = NULL;</span>
</code></pre>
<ul>
<li>Утечка памяти (memory leak): теперь память из первой строки<br>
невозможно освободить (мы потеряли адрес)</li>
<li>Такие ошибки можно искать утилитой valgrind<br>
Вопрос! В современных ОС вся память, выделенная программой, после ее завершения возвращается системе (даже если была утечка). Зачем бороться с утечками?</li>
</ul>
<ol>
<li>Сервер (работает без перезапуска). Утечка при каждом запросе пользователя.</li>
<li>Сначала все замедлится (файл подкачки), потом ОС аварийно завершит процесс.</li>
</ol>
<h4 id="вычислительная-сложность-2">Вычислительная сложность</h4>
<p><strong>malloc должен:</strong></p>
<ol>
<li>Пройти по списку (одна из возможным реализаций) выделенных<br>
областей</li>
<li>Найти непрерывную область нужного размера<br>
Это <em>гораздо дольше</em> чем на стеке и у глобальных переменных!</li>
</ol>
<h4 id="еще-методы-работы-с-кучей">Еще методы работы с кучей</h4>
<ul>
<li><strong>calloc</strong> — выделяет память и инициализирует ее нулями</li>
<li><strong>realloc</strong> — изменяет размер уже существующего массива.</li>
</ul>
<p>Существует три результата работы функции:</p>
<ol>
<li>если нужное число байт не занято в смежной области, то увеличивает область для массива</li>
<li>если рядом нет свободной памяти, перенесет массив в другое место</li>
<li>если вообще нет памяти под увеличенный массив, вернет 0</li>
</ol>
<h3 id="void">void*</h3>
<p>По своей сути это указатель на любой тип данных. Т.к. void не имеет размерности, то с ним не будет работать арифметика указателей. Такой указатель всегда нужно приводить к какому-то классическому типу.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> array<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span>
<span class="token number">3</span> product_t array1<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">int</span> arrray2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token function">qsort</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token function">qsort</span><span class="token punctuation">(</span>array2<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre>
<ul>
<li>void* — не работает адресная арифметика</li>
<li>В С++ требуется явное приведение типов (в С можно неявно)</li>
<li>void* malloc(…) (malloc возвращает void* )</li>
</ul>
<h2 id="и-5.-структуры.-неинтрузивный-связный-список-на-c.-интрузивный-связный-список-на-c">4 и 5. Структуры. Неинтрузивный связный список на C. Интрузивный связный список на C</h2>
<h3 id="синтаксис-структур.-применение">Синтаксис структур. Применение</h3>
<p>Сущность описывается набором переменных: точка в 3D, товар в программе автоматизации на складе (название, вес, количество, …) и т.д.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">struct</span> product_s <span class="token punctuation">{</span>
<span class="token number">2</span> 	<span class="token keyword">char</span> label<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">3</span> 	<span class="token keyword">float</span> weight<span class="token punctuation">;</span>
<span class="token number">4</span> 	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">6</span>
<span class="token number">7</span> <span class="token keyword">struct</span> product_s p <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Milk"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//Инициализация</span>
<span class="token number">8</span> 
<span class="token number">9</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s %f %d"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span>
<span class="token number">11</span> <span class="token keyword">struct</span> product_s array<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">12</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token number">13</span>
<span class="token number">14</span> <span class="token keyword">struct</span> product_s<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> product_s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">15</span> ptr<span class="token operator">-&gt;</span>weight <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre>
<p>Структуры полностью копируются (оператор = требует линейное время)<br>
Тонкость: при копирвании указателя будет скопировано значение указателя, а не данные, на которые он ссылается.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">struct</span> product_s a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%f%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// Полностью копирует все поля, даже массивы.</span>
<span class="token number">4</span> a<span class="token punctuation">.</span>price <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>price<span class="token punctuation">,</span> b<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Разные значения.</span>
</code></pre>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">struct</span> array_s <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token keyword">struct</span> array_s a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> a<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">7</span> a<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token number">8</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> a<span class="token punctuation">.</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Одинаковые значения</span>
</code></pre>
<p>Особенность: в C/C++ структуры можно размещать на стеке, в глобальной памяти и на куче (malloc). В то время как в Python и Java только на куче.</p>
<p>Структуры можно передавать в функции в качестве параметров через стек. В таком случае нам придется скопировать на стек sizeof(product_s) байт для параметра функции и столько же для возвращаемого значения. Это может быть очень долго. Если в функции идейно не требуется копия стурктуры, то следует передать структуру через указатель.</p>
<ul>
<li>Указатель всегда занимает одно и то же число байт вне зависимости от типа переменной, на которую указывает.</li>
<li>Указатель позволяет менять значение (для структур — значение полей) переданной переменной.</li>
</ul>
<h3 id="typedef">typedef</h3>
<p><strong>typedef</strong> - вводит новое имя (синоним) для существующего типа.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> product_s product_t<span class="token punctuation">;</span> <span class="token comment">//псевдоним</span>
<span class="token number">2</span> product_t p<span class="token punctuation">;</span> <span class="token comment">// меньше букв</span>
</code></pre>
<blockquote>
<p>size_t — тип переменной, которая содержит размер любой сущности в памяти (например, может быть определен как typedef unsigned long size_t).</p>
</blockquote>
<p>Главное отличие от <em>define</em> в том, что <em>typedef</em> выполняется компилятором, который выяснил типы индентификаторов перед подстановкой (<em>typedef</em>применится только к типам, define к любому индетификатору)</p>
<h3 id="неинтрузивный-и-интрузивный-связный-список">Неинтрузивный и интрузивный связный список</h3>
<p><em>&lt;добавить картинку&gt;</em></p>
<p>Иногда нам может потребоваться структура, которая хранит в себе элементы и не ограничена константным размером. Мы хотим, чтобы структура динамически росал. Есть два варианта: <em>vector</em> или <em>связный список</em></p>
<h4 id="какими-методами-обладает-связный-список">Какими методами обладает связный список</h4>
<ul>
<li>Размер увеличивается при добавлении элементов.</li>
<li>
<ul>
<li>Каждый элемент выделяется с помощью malloc</li>
</ul>
</li>
<li>
<ul>
<li>Элементы расположены на произвольных адресах (в векторе - последовательно).</li>
</ul>
</li>
<li>
<ul>
<li>Каждый элемент хранит адреса последующего и предыдущего.</li>
</ul>
</li>
<li>Функции для создания и удаления</li>
<li>Функции добавления элемента</li>
<li>Функции для вывода на экран</li>
<li>Функции для обращения элементам</li>
<li>Функции вставки и удаления элементов</li>
<li>
<ul>
<li>Из-за того что элементы расположены непоследовательно, не требуется смещать все остальные элементы</li>
</ul>
</li>
</ul>
<h4 id="различия-между-между-вектором-и-связным-списком">Различия между между вектором и связным списком</h4>
<ol>
<li>Т.к. в векторе элементы расположены последовательно, то найти i-ый элемент не составляет трудности. В то время как в связном списке придется шагать по адресам, что гораздо дольше.</li>
<li>Т.к. в векторе элементы расоложены последовательно, то добавление или удаление одного жлемента приведет к свдигу всех остльных, что очень затратно. В то время как в связном списке для подобных операций достаточно обновить указатели соседних элментво - очень быстро.</li>
</ol>
<h4 id="различия-интрузивного-и-неинтрузивного-связного-списка">Различия интрузивного и неинтрузивного связного списка</h4>
<p>В данном случае слово интрузивнй означет подход к связи данных и списка.<br>
В <strong>неинтрузивном</strong> связаном списке элемент структуры <em>данные</em> хранится в структуре <em>элменте списка</em>.<br>
В <strong>интрузивном</strong> связном списке структура <em>элемент списка</em> хранится в в элементе структуры <em>данные</em></p>
<p><em>Иинтрузивный</em> список позволяет решить проблему двух malloc. В <em>неинтрузивном</em> списке, если наши данные представлены какой-либо структурой, то под них придется выделять память при создании <em>элемента списка</em>, при этом необходимо будет создать и сам <em>элемент списка</em>.</p>
<h2 id="функции.-указатели-на-функции">6. Функции. Указатели на функции</h2>
<h3 id="как-вызывается-функция">Как вызывается функция</h3>
<p>При компиляции в объектном файле остаются места с названием функций, без указания как их вызвать. Дальше проходит линкер и заменяет каждое название функции на адрес ее реализации. При вызове функции выделяется кадр на стеке, в котором выделяетс память под все параметры функции, а также под возвращаемое значение и адрес возврата.</p>
<h3 id="реализация-сортировки">Реализация сортировки</h3>
<p>Идея: Разделяем массив на две части. Делим пока не дойдем до элементарных частей (размер кусочков равен 1 или 0). Дальше сливаем кусочки друг с другом. Слияние: сравниваем поэлементно два массива, вначале записываем меньший(больший) элемент, затем продолжаем сраванивать и записывать. Как только закончится один из массивов, записываем до конца оставшиеся элементы второго массива.</p>
<ol>
<li>Если в рассматриваемом массиве один элемент, то он уже отсортирован — алгоритм завершает работу.</li>
<li>Иначе массив разбивается на две части, которые сортируются рекурсивно.</li>
<li>После сортировки двух частей массива к ним применяется процедура слияния, которая по двум отсортированным частям получает исходный отсортированный массив.</li>
</ol>
<p>Универсальность добивается за счет того, что в качестве параметра передается размер в байтах сортируемых элементов. В самой реализации все работает через char*, т.к. sizeof(char) = 1 байт, следовательно, им просто удобно итерироваться с помощью адресной арифметики.<br>
Элементы меняются местами побайтово. Чтобы перезаписать какой-либо элемент из одного массива в другой, необходимо перенести отдельно каждый байт этого элемента на новое место.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span>  <span class="token function">merge</span><span class="token punctuation">(</span>
size_t element_size<span class="token punctuation">,</span> 
<span class="token keyword">char</span><span class="token operator">*</span> left<span class="token punctuation">,</span>
<span class="token keyword">char</span><span class="token operator">*</span> mid<span class="token punctuation">,</span>
<span class="token keyword">char</span><span class="token operator">*</span> right<span class="token punctuation">,</span>
<span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>comparator<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span>  <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span>  <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	 size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 size_t elements <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> element_size<span class="token punctuation">;</span>
	 <span class="token keyword">char</span><span class="token operator">*</span> result <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>elements <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">if</span>  <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">while</span>  <span class="token punctuation">(</span>left <span class="token operator">+</span> i <span class="token operator">*</span> element_size <span class="token operator">&lt;</span> mid <span class="token operator">&amp;&amp;</span> mid <span class="token operator">+</span> j <span class="token operator">*</span> element_size <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">comparator</span><span class="token punctuation">(</span>left <span class="token operator">+</span> i <span class="token operator">*</span> element_size<span class="token punctuation">,</span> mid <span class="token operator">+</span> j <span class="token operator">*</span> element_size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> element_size<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
				 <span class="token operator">*</span><span class="token punctuation">(</span>result <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> element_size<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>left <span class="token operator">+</span> k <span class="token operator">+</span> i <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
			 i<span class="token operator">++</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
		 <span class="token keyword">else</span> <span class="token punctuation">{</span>
			 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> element_size<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
				 <span class="token operator">*</span><span class="token punctuation">(</span>result <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> element_size<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> k <span class="token operator">+</span> j <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
			 j<span class="token operator">++</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">while</span>  <span class="token punctuation">(</span>left <span class="token operator">+</span> i <span class="token operator">*</span> element_size <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> element_size<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
			 <span class="token operator">*</span><span class="token punctuation">(</span>result <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> element_size<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>left <span class="token operator">+</span> k <span class="token operator">+</span> i <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		 i<span class="token operator">++</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">while</span>  <span class="token punctuation">(</span>mid <span class="token operator">+</span> j <span class="token operator">*</span> element_size <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> element_size<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
			 <span class="token operator">*</span><span class="token punctuation">(</span>result <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> element_size<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> k <span class="token operator">+</span> j <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		 j<span class="token operator">++</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">for</span>  <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> element_size<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			 <span class="token operator">*</span><span class="token punctuation">(</span>left <span class="token operator">+</span> k <span class="token operator">+</span> l <span class="token operator">*</span> element_size<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>result <span class="token operator">+</span> k <span class="token operator">+</span> l <span class="token operator">*</span> element_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
	 <span class="token punctuation">}</span>
	 <span class="token function">free</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">int</span>  <span class="token function">mergesort</span><span class="token punctuation">(</span>
	 <span class="token keyword">void</span><span class="token operator">*</span> array<span class="token punctuation">,</span>
	 size_t elements<span class="token punctuation">,</span> size_t element_size<span class="token punctuation">,</span>
	 <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>comparator<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span>  <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span>  <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	 <span class="token keyword">int</span> status<span class="token punctuation">;</span>
	 <span class="token keyword">char</span><span class="token operator">*</span> arr <span class="token operator">=</span> array<span class="token punctuation">;</span>
	 size_t m <span class="token operator">=</span> elements <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	 <span class="token keyword">if</span>  <span class="token punctuation">(</span>elements <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		 <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>
	 status <span class="token operator">=</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m<span class="token punctuation">,</span> element_size<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 status <span class="token operator">=</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> m <span class="token operator">*</span> element_size<span class="token punctuation">,</span> elements <span class="token operator">-</span> m<span class="token punctuation">,</span> element_size<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">if</span>  <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		 <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token keyword">char</span><span class="token operator">*</span> left <span class="token operator">=</span> arr<span class="token punctuation">;</span>
	 <span class="token keyword">char</span><span class="token operator">*</span> mid <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token punctuation">(</span>elements <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> element_size<span class="token punctuation">;</span>
	 <span class="token keyword">char</span><span class="token operator">*</span> right <span class="token operator">=</span> arr <span class="token operator">+</span> elements <span class="token operator">*</span> element_size<span class="token punctuation">;</span>
	 <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">merge</span><span class="token punctuation">(</span>element_size<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		 <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="обзор-стандартной-библиотеки-c">7. Обзор стандартной библиотеки C</h2>
<h3 id="string.h---работа-со-строками-и-массивами">string.h - работа со строками и массивами</h3>
<p><strong>memcpy</strong> - функция копирует n байт из массива (области памяти), на который указывает аргумент source, в массив (область памяти), на который указывает аргумент destination. Если массивы перекрываются, результат копирования будет не определен.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memcpy</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>destination<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>source<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>memcmp</strong> - функция сравнивает первые count символов массивов, на которые указывают buf1 и buf2. Сравнение производится лексикографически. Функция memcmp() возвращает целое число, которое интерпретируется, как указано ниже:</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>_buf1_<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>_buf2_<span class="token punctuation">,</span> size_t _count_<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p>Функция memcmp() возвращает целое значение, которое интерпретируется следующим образом.</p>

<table>
<thead>
<tr>
<th>Число</th>
<th>Значение</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 0</td>
<td>buf1 меньше, чем buf2</td>
</tr>
<tr>
<td>0</td>
<td>buf1 равен buf2</td>
</tr>
<tr>
<td>&gt; 0</td>
<td>buf1 больше, чем buf2</td>
</tr>
</tbody>
</table><p><strong>strcpy</strong> - аналог <em>memcpy</em> только работает на строки</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strcpy</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> destptr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> srcptr <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>strcmp</strong> - аналог <em>memcmp</em> только работает со строками</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">strcmp</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>strcat</strong> - функция добавляет в строку, на которую указывает аргумент destination, строку, на которую указывает аргумент append. Символ конца строки помещается в конце объединенных строк.</p>
<p>Следует иметь в виду, что функция не производит проверки границ, поэтому программист должен сам позаботиться о том, чтобы строка str1 была достаточно длинной и могла вместить помимо своего первоначального содержания еще и содержание строки str2.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcat</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>destination<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>append<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>strstr</strong> - функция ищет первое вхождение строки (за исключением признак конца строки), на которую указывает аргумент strA, в строку , на которую указывает аргумент strB. Если строка strA имеет нулевую длину, то функция вернет указатель на начало строки strB.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strstr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strB<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>strchr</strong> - функция ищет первое вхождения символа, код которого указан в аргументе ch, в строке, на которую указывает аргумент str.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strchr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>strtok</strong> - функция выделяет очередную часть строки, на которую указывает аргумент str, отделенную одним из символов разделителей указанных в строке, на которую указывает аргумент sep. Последовательный вызов функции strtok приводит к разбиению строки str на части (лексемы).</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strtok</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sep<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h3 id="stdlib.h---работа-с-памятью-алгоритмами">stdlib.h - работа с памятью, алгоритмами</h3>
<p><strong>atoi</strong> - aункция конвертирует строку, на которую указывает параметр str, в величину типа int. Строка должна содержать корректную запись целого числа. В противном случае возвращается 0.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
</code></pre>
</blockquote>
<p><strong>strtol</strong> - функция преобразует строковое представление числа, которое содержится в строке, адресуемой параметром-указателем <em>start</em>, в значение типа <em>long int</em> и возвращает полученный результат. Основание системы счисления, в которой представлено преобразуемое число, определяется параметром <em>radix</em>.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">strtol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>_start_<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>_end_<span class="token punctuation">,</span> <span class="token keyword">int</span> _radix_<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>srand/rand</strong> - Функция <em>srand()</em> используется для установки начала последовательности, генерируемой функ­цией <em>rand()</em> (функция <em>rand()</em> возвращает псевдослучайные числа).</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> seed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>qsort</strong> - Функция qsort() сортирует массив, на который указывает параметр base, используя quicksort — алгоритм сортировки широкого назначения, разработанный С. Р. Хори. После завершения фун­кции массив становится отсортированным. Параметр num задает число элементов массива, пара­метр size задает размер в байтах каждого элемента.</p>
<blockquote>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> size_t num<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<blockquote>
<p>Функция, на которую указывает параметр compare, сравнивает элементы массива с ключом. Формат функции compare следующий:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">func_name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h2 id="и-9.-ввод-вывод-на-c.-текстовые-файлы.-бинарные-файлы">8 и 9. Ввод-вывод на C. Текстовые файлы. Бинарные файлы</h2>
<p><strong>FILE</strong> - этот тип данных определяет поток и содержит информацию, необходимую для управления потоком, в том числе указатель на буфер потока, и его показатели состояния.</p>
<p>При подключении заголовочного файла <code>&lt;stdio.h&gt;</code> в проект, автоматически создаются три объекта типа <code>FILE*</code>, потоки ввода/вывода и стандартный поток ошибок. К этим потокам можно обратиться через указатели <code>stdin</code>, <code>stdout</code> и <code>stderr</code>.</p>
<p><strong>fopen</strong> - функция fopen() открывает файл, имя которого указано аргументом fname, и возвращает свя­занный с ним указатель. Тип операций, разрешенных над файлом, определяется аргументом mode.</p>

<table>
<thead>
<tr>
<th>Режим</th>
<th>Значение</th>
</tr>
</thead>
<tbody>
<tr>
<td>“r”</td>
<td>Открывает файл для чтения (по умолчанию файл открывается как текстовый).</td>
</tr>
<tr>
<td>“w”</td>
<td>Создает файл для записи (по умолчанию файл открывается как текстовый).</td>
</tr>
<tr>
<td>“rb / rw”</td>
<td>Работа с бинарными фалйми</td>
</tr>
<tr>
<td>“rt / wt”</td>
<td>Работа с текстовыми файлами</td>
</tr>
</tbody>
</table><p><strong>fclose</strong> - функция fclose() используется для закрытия потока, ранее открытого с помощью fopen(). Она сохраняет в файл данные, находящиеся в дисковом буфере, и выполняет операцию системного уровня по закрытию файла. Вызов fclose() освобождает блок управления файлом, связанный с потоком, и делает его доступным для повторного использования.</p>
<p>Стандарт Си определяет три вида буферизации потоков:</p>
<ul>
<li><em>Небуферизированные</em>  потоки (<em>unbuffered</em>) — буферизации на стороне программы/libc как таковой нет: все данные по возможности сразу передаются ОС/устройству.</li>
<li><em>Полностью буферизированные</em>  (<em>fully buffered</em>) — данные записываются в буфер и будут фактически выведены только при его заполнении или при его принудительном сбросе.</li>
<li><em>Линейно-буферизированные</em>  (<em>line buffered</em>) — данные буферизируются, но выводятся, если в потоке встретится символ конца строки (<code>\n</code>), если буфер будет полностью заполнен или принудительно сброшен. Также все  <em>линейно-буферизированные</em>  потоки вывода (в частности  <code>stdout</code>) сбрасываются, когда какой-либо (обычно другой, например,  <code>stdin</code>)  <em>линейно-буферизированный</em>  поток пытается что-либо прочитать, а его буфер ввода пуст.</li>
</ul>
<p><strong>printf</strong> - Функция printf() записывает в stdout аргументы из списка arg-list под управлением строки, на которую указывает аргумент format.</p>
<p><strong>fprintf</strong> - Функция fprintf() выводит значения аргументов, составляющих список arg-list, в формате, указан­ном в строке format, в поток, на который указывает srtream. Возвращаемая величина — это число действительно выведенных символов. В случае ошибки возвращается отрицательное значение.</p>
<p><strong>scanf</strong> - Функция scanf() является процедурой ввода общего назначения, считывающей данные из пото­ка stdin. Она может считывать данные всех базовых типов и автоматически конвертировать их в нужный внутренний формат. Если бы printf() выполняла ввод, а не вывод, ее можно было бы назвать аналогом scanf().</p>
<p><strong>fscanf</strong> - Функция fscanf() работает точно так же, как функция scanf(), за исключением того, что она считывает информацию из потока, указанного аргументом stream, а не из stdin.</p>
<p><strong>sprintf</strong> - Функция sprintf() идентична printf(), за исключением того, что вывод производится в массив, указанный аргументом buf.</p>
<p><strong>sscanf</strong> - Функция sscanf() идентична функции scanf() во всем, кроме того, что данные считываются из массива, указанного аргументом buf, а не из файла stdin.</p>
<p><strong>fgets</strong> - Функция fgets() считывает до num-1 символов из файла stream и помещает их в массив символов, на который указывает str. Символы считываются до тех пор, пока не встретится символ «новая строка», EOF или до достижения указанного предела. По окончании считывания в массив str сразу после последнего считанного символа помещается нулевой символ. Символ «новая строка» при считывании будет сохранен и станет частью массива str.</p>
<h3 id="обработка-ошибок">Обработка ошибок</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span>fin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> 	<span class="token function">fread</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token number">3</span> 	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">4</span> 	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">5</span> 	<span class="token punctuation">}</span>	
<span class="token number">6</span> <span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>feof</strong> возвращает индикатор конца файла<br>
Макросом feof() контролируется указатель положения в файле — для того, чтобы установить, достигнут ли конец файла, связанный с потоком stream. Если указатель положения в файле нахо­дится в конце файла, то возвращается ненулевое значение; в противном случае возвращается нуль.</li>
<li><strong>ferror</strong> - возвращает индикатор ошибки<br>
Функция ferror() проверяет, имеются ли файловые ошибки в данном потоке stream. Возврат 0 означает отсутствие ошибок, а ненулевая величина указывает на наличие ошибки.</li>
</ul>
<p>Сначала fread перейдет чтением «за конец файла», а потом установит индикатор (не заранее).<br>
ferror, feof — была ли при последней операции с файлом получена ошибка/достигнут конец файла.</p>
<p><strong>fread</strong> - Функция fread() считывает count объектов — каждый объект по size символов в длину — из потока, указанного stream, и помещает их в символьный массив, указанный в buf. Указатель пози­ции в файле продвигается вперед на количество считанных символов.</p>
<p><strong>fwrite</strong> - Функция fwrite() записывает count объектов — каждый объект по size символов в длину — в поток, указанный stream, из символьного массива, указанного buf. Указатель позиции в файле продвигается вперед на количество записанных символов.</p>
<p><strong>fseek</strong> - переместиться на заданную позицию в файле (удобно пропускать ненужные поля в заголовке бинарного файла). Функция fseek() устанавливает указатель положения в файле, связанном со stream, в соответ­ствии со значениями offset и origin. Ее основное назначение — поддерживать операции ввода/ вывода по произвольному адресу. Аргумент offset — это выраженный в байтах сдвиг от позиции, определяемой origin, до новой позиции. Аргумент origin может принимать значения 0, 1 или 2, причем 0 означает начало файла, 1 — текущую позицию, а 2 — конец файла.</p>
<p><strong>ftell</strong> - возвращает текующую позицию. Функция ftell() возвращает текущее значение указателя положения в файле для указанного потока. Это значение представляет собой количество байт, на которое указатель отстоит от начала файла.</p>
<p><strong>fflush</strong> - Если stream связан с файлом, открытым для записи, то вызов fflush() приводит к физической записи содержимого буфера в файл. Если же stream указывает на вводимый файл, то очищается входной буфер. В обоих случаях файл остается открытым.</p>
<h2 id="ключевые-слова-extern-static-inline">10. Ключевые слова <code>extern</code>, <code>static</code>, <code>inline</code></h2>
<h3 id="extern-у-переменных"><code>extern</code> у переменных</h3>
<p>Поскольку С позволяет выполнять раздельную компиляцию модулей для большой программы в целях ускорения компиляции и помощи управлению большими проектами, должны быть способы передачи информации о глобальных переменных файлам программы. Решение заключается в объявлении всех глобальных переменных в одном файле и использовании при объявлении в других файлах слова extern</p>
<p>Если при объявлении выделяется память под переменную, то процесс называется определением. Использование extern приводит к объявлению, но не к определению. Оно просто говорит компилятору, что определение происходит где-то в другом месте программы.</p>
<pre class=" language-c"><code class="prism  language-c">  <span class="token number">1</span><span class="token punctuation">.</span>h
<span class="token number">1</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> last_rnd<span class="token punctuation">;</span>

  <span class="token number">1</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> <span class="token keyword">int</span> last_rnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//выделение памяти</span>
<span class="token number">2</span> <span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">3</span> last_rnd <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//текущее время</span>
<span class="token number">4</span> <span class="token punctuation">}</span>

  <span class="token number">2</span><span class="token punctuation">.</span>cpp
<span class="token number">1</span> #include <span class="token string">"1.h"</span>
<span class="token number">2</span> <span class="token comment">//extern -&gt; выделение памяти происходит в другом месте</span>
<span class="token number">3</span> <span class="token comment">// (также знаем тип переменной)</span>
<span class="token number">4</span> <span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">5</span> last_rnd <span class="token operator">=</span> <span class="token punctuation">(</span>lst_rnd <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> <span class="token number">113</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">43</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">return</span> last_rnd<span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token punctuation">}</span>
</code></pre>
<h2 id="static-у-переменных-и-функций"><code>static</code> у переменных и функций</h2>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// сохраняет значение между вызовами функции</span>
<span class="token number">2</span> <span class="token keyword">static</span> <span class="token keyword">int</span> call_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//инициализируется один раз</span>
<span class="token number">3</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">4</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Called times: %d"</span><span class="token punctuation">,</span> call_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> call_count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
<span class="token number">7</span>
<span class="token number">8</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">9</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token punctuation">}</span>
</code></pre>
<p>Слово static имеет два разных смысла в зависимости от контекста.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Глобальная переменная (видна во всех файлах)</span>
<span class="token number">2</span>
<span class="token number">3</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Глобальная переменная</span>
<span class="token number">4</span> <span class="token comment">// (видна только в этом файле)</span>
<span class="token number">5</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">6</span> <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Статическая переменная</span>
<span class="token number">7</span> <span class="token comment">// (видна только в функции)</span>
<span class="token number">8</span> <span class="token punctuation">}</span>
</code></pre>
<ul>
<li>К переменной a можно обращаться из других файлов при помощи extern.</li>
<li>Переменная b не будет видна из других файлов даже если есть extern.</li>
<li>Переменную c вообще не имеет смысла видеть в других файлах.</li>
</ul>
<p><strong>static</strong> у глобальной переменной или функции — идентификатор используется только для разрешения имен в рамках одного файла</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token comment">//tree.c</span>
<span class="token number">2</span> <span class="token keyword">static</span> tree_t node<span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fill_nodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tree_t t<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token number">4</span> <span class="token comment">//list.c</span>
<span class="token number">5</span> <span class="token keyword">static</span> list_t node<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fill_nodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> list_t l<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre>
<p>В ELF файл попадут обе функции.</p>
<h2 id="inline-у-функций"><code>inline</code> у функций</h2>
<p>“Заинлайнить” — оптимизация компилятора.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token comment">// До:</span>
<span class="token number">1</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">else</span>
<span class="token number">5</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
<span class="token number">7</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">8</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span> <span class="token punctuation">}</span>
</code></pre>
<pre class=" language-c"><code class="prism  language-c"><span class="token comment">// После:</span>
<span class="token number">1</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token number">5</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token keyword">else</span>
<span class="token number">7</span> d <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token number">8</span>
<span class="token number">9</span> <span class="token punctuation">}</span>
</code></pre>
<p>Компилятор принимает такие решения самостоятельно. Можно дать совет -O0, -O1, -O2, -O3 (уровень оптимизации).</p>
<pre class=" language-c"><code class="prism  language-c">  a<span class="token punctuation">.</span>c
<span class="token number">1</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">else</span>
<span class="token number">5</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
  b<span class="token punctuation">.</span>c
<span class="token number">1</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Такой код заинлайнить нельзя, потому что на стадии компиляции определение функции max недоступно при компиляции b.c</p>
</blockquote>
<pre class=" language-c"><code class="prism  language-c">  a<span class="token punctuation">.</span>h
<span class="token number">1</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">else</span>
<span class="token number">5</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
  b<span class="token punctuation">.</span>c
<span class="token number">1</span> #include <span class="token string">"a.h"</span>
<span class="token number">2</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  c<span class="token punctuation">.</span>c
<span class="token number">1</span> #include <span class="token string">"a.h"</span>
<span class="token number">2</span> <span class="token function">g</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> g <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Заинлайнится, но будет ошибка double definition на линковке.</p>
</blockquote>
<pre class=" language-c"><code class="prism  language-c">  a<span class="token punctuation">.</span>h
<span class="token number">1</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">else</span>
<span class="token number">5</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token punctuation">}</span>
  b<span class="token punctuation">.</span>c
<span class="token number">1</span> #include <span class="token string">"a.h"</span>
<span class="token number">2</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  c<span class="token punctuation">.</span>c
<span class="token number">1</span> #include <span class="token string">"a.h"</span>
<span class="token number">2</span> <span class="token function">g</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Линкер выберет один какой-то вариант функции. В ELF файл попадет одна функция.</p>
</blockquote>
<h2 id="разное-">Разное :)</h2>
<h3 id="ключевое-слово-const-1">ключевое слово <code>const</code></h3>
<p><strong>Константы</strong> — фиксированные величины, которые не изменяются во время выполнения программы. Эти фиксированные величины также называются <strong>литералами</strong>.</p>
<h4 id="const-у-переменной-1">const у переменной</h4>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">float</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span>
</code></pre>
<ul>
<li>Компилятор проверит, чтобы мы не изменили число pi.</li>
<li>Дает больше информации программисту, читающему или используещему этот код.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">print_hex</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>Программист подчеркнул, что функция не изменит параметр внутри себя</p>
</blockquote>
<h4 id="const-у-указателя-1">const у указателя</h4>
<p>const защищает то, что <strong>перед</strong> ним.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token number">1</span> <span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"bye"</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token number">4</span> p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment">// compilation error</span>
<span class="token number">5</span> p1 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token number">6</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token number">7</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token number">8</span> p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">// compilation error</span>
<span class="token number">9</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
Но можно и так<span class="token punctuation">:</span>
<span class="token number">1</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p1<span class="token punctuation">;</span> <span class="token comment">// equal to char const * p1;</span>
</code></pre>
<h3 id="функции-с-переменным-числом-параметров">Функции с переменным числом параметров</h3>
<pre class=" language-c"><code class="prism  language-c">  va_start<span class="token punctuation">,</span> va_arg<span class="token punctuation">,</span> va_end — макросы<span class="token punctuation">.</span>
<span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">simple_printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">2</span> va_list args<span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token comment">//записать в args адрес следующего за fmt параметра на стеке</span>
<span class="token number">4</span> <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">6</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>fmt<span class="token operator">==</span><span class="token string">'d'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">7</span> <span class="token comment">//достать со стека переменную типа int</span>
<span class="token number">8</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token number">9</span> <span class="token comment">// здесь должен быть код, который</span>
<span class="token number">10</span> <span class="token comment">// выводит int на экран с помощью putc</span>
<span class="token number">11</span> <span class="token punctuation">}</span>
<span class="token number">12</span> fmt<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token number">13</span> <span class="token punctuation">}</span>
<span class="token number">14</span> <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">15</span> <span class="token punctuation">}</span>
<span class="token number">16</span> <span class="token comment">//Труднообнаруживаемые ошибки</span>
<span class="token number">17</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">18</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="библиотеки">Библиотеки</h3>
<p><strong>Статические</strong> (*.a, *.lib): объектные файла из библиотеки присоеднияются к программе в момент линковки.</p>
<ul>
<li>Легко установить (не нужно отдельно загружать библиотеку)</li>
<li>При выходе новой версии библиотеки (например, исправлен баг) автору программы нужно послать пользователю пересобранную версию</li>
</ul>
<p><strong>Динамические</strong> (*.so, *.dll): хранятся отдельно, связывание программы и библиотеки происходит в момент выполнения (помогает отдельная компонента — загрузчик).</p>
<ul>
<li>Необходимо отдельно установить все необходимые библиотеки (решение: packages and repositories)</li>
<li>При выходе новой версии библиотеки (например, исправлен баг) пользователь может самостоятельно обновить только библиотеку без пересборки программы.</li>
</ul>
<p>Для использования библиотеки нужно: *.a или *.so и заголовочные файлы<br>
Ключи:</p>
<ul>
<li>имя библиотеки (-lexpat)</li>
<li>static сборка со статической версией библиотеки (по умолчанию динамическая)</li>
</ul>
<p>Еще бывает загрузка динамической библиотеки по запросу (плагины)</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>library_name<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div>
</body>

</html>
