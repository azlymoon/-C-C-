
# Экзамен: "Углубленный C/C++"

## 1. Программа, состоящая из нескольких файлов
Главная причина: упрощение разработки программы.

**Зачем программу разбивают на части?**
- Небольшую часть проще понять.
- Небольшую часть проще тестировать и отлаживать.
- Разные части могут разрабатывать разные люди.
- Отдельные части проще использовать в новых проектах.

Разбивают программу на *функции* и *файлы*.

### Компиляция и линковка
Компиляция: main.c -> main.o, util.c -> util.o (объектный файл)
Линковка: main.o util.o -> main.exe 
**Объектный файл** представляет из себя бинарник, в котором имена функций еще не заменены адресами.
**Линкер** должен склеить файлы вместе и заменить вызовы функции по имени на вызовы по адресу (процессор понимает только числа - адреса).
**Особенность компиляции:** *файлы компилируются независимо друг от друга, соответсвенно, при компиляции один файл не знает никакой информации о другом! После этого они линкуются*
**Преимущество такого подхода:** программисту не нужно компилировать весь проект с нуля при изменении только одного файла. Например: изменения были в util.c, соответсвенно, перекомпилировали util.c -> util.o, далее опять слинковали util.o main.o (main.o заново не компилировался) и получили новый исходник. 
>Операция компиляции вычислительно сложнее (подбор команд, регистров, ячеек памяти), чем линковка (два прохода по исполняемому файлу: 1. составить таблицу имя функции <–> адрес; 2. заменить вызовы по имена на адрес из таблицы.)

### Заголовочные файлы
**Типовые ошибки линковки**
- undefined refernce (есть вызов, нет функции)
- multiple definition (несколько функций с одинаковым именем)
Компилятор языка C не помещает в объектный код информацию (количество, типы) о параметрах функции, а линкер не проверяет соответствие между вызовом и определением функции (definition).

``` C
1 //main.c
2 int main() {
3 int a = 3; int b = 5;
4 int c = a + b;
5 int d = sum(c);
6 return 0;
7 }

1 //util.c
2 int sum(int a, int b) { // definition
3 return a + b;
4 }
```
>Ошибка времени выполнения: sum возьмет из памяти произвольное
число в качестве второго параметра.

```C
1 //main.c
2 #include "util.h"
3 int main() {
4 int a = 3; int b = 5;
5 int c = a + b;
6 int d = sum(c); // compilation error
7 return 0;
8 }

1 //util.c
2 #include "util.h"
3 int sum(int a, int b) { // definition
4 return a + b;
5 }

1 //util.h
2 int sum(int a, int b); // declaration
```
>Решение: поместить объявление (declaration) функции в
заголовочный файл

- Директива include вставляет содержимое файла util.h в исходный код.
- Результат: на стадии компиляции будут выявлены несоответствия между объявлением и определением, между вызовом и объявлением => между вызовом и определением.
>Программа –> [Препроцессор] –> [Компилятор] –> [Ассемблер] –> Объектный файл

### Препроцессор
Простая программа, задача которой заключается в том, чтобы вставить или заменить какие-либо строчки в коде. 
> #include  (вставляет содержимое файла в код) выполняется препроцессором 

**#define** - определяет последовательность символов, которой будет заменяться индетификатор (просто взамен одного подставляет другое). Также выполняется препроцессором.
>_#define имя_макроса последовательность_символов_ 

>Пример:
>``` C
>#define TRUE 1  
>#define FALSE 0  
>```
>В результате, если компилятор обнаружит в тексте программы TRUE или FALSE, то он заменит их на 1 и 0 соответственно. Например, следующая строка выводит на экран «0 1 2»:  
>```C
> printf ("%d %d %d", FALSE, TRUE, TRUE + 1);
> ```
 **#ifdef, #ifndef, #else, #endif**
Директивы условной компиляции препроцессора позволяют компилировать или пропускать часть программы в зависимости от выполнения некоторого условия.

Условие может принимать одну из описываемых ниже форм.
```C
#ifdef identifier  
// код, находящийся здесь, компилируется, если identifier уже был определен для препроцессора в команде #define.  
#endif

#ifndef identifier  
// код, находящийся здесь, компилируется, если identifier в данный момент не определен командой препроцессора #define.  
#endif
```
За любой из команд условной компиляции может следовать произвольное число строк, содержащих, возможно, команду вида #else и заканчивающихся #endif. Если проверяемое условие справедливо, то строки между #else и #endif игнорируются. Если же проверяемое условие не выполняется, то игнорируются все строки между проверкой и командой #else, а если ее нет, то командой #endif.
```C
// util.h
#ifndef UTIL_H_
#define UTIL_H_
// ...
#endif 
```
### Утилита make
**make** — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:  
  
1) целями (то, что данное правило делает);  
2) реквизитами (то, что необходимо для выполнения правила и получения целей);  
3) командами (выполняющими данные преобразования).  
  
В общем виде синтаксис makefile можно представить так:  
  

```
# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда #1>
	...
	<команда #n>
```
## 2. Указатели, массивы 
**Указатель** - число, адрес (т.е. смещение от начала соответствующего элемента в памяти)
**int* p** - указатель на ячейку, в которой хранится int (в 'p' будет хранится адрес)
```C
1 int a = 42;
2 int *p = &a; // & -- взять адрес a
3 int b = *p; // взять значение по адресу p (разыменовать)
4 printf("%p", p); // вывести адрес
```
### Арифметика указателей
Сдвиг зависит от типа объектов, на который указывает указатель
```C
1 int array[5] = {1, 2, 3, 4, 5};
2 char str[] = "hello";
3 int *pi = array; // pi = &array[0]
4 char *pc = str; // pc = &str[0]
5 pi += 1; // сдвиг адреса на sizeof(int)
6 pc += 1; // сдвиг адреса на sizeof(char)

array[i] == i[array]:
1 array[i] --> *(array + i)
2 i[array] --> *(i + array)
```

### Применение указателей 
#### 1. Возврат нескольких значений из функции
```C
1 void swap(double *pa, double *pb){
2 double tmp = *pa;
3 *pa = *pb;
4 *pb = tmp;
5 }
6 int main() {
7 double c = 3; double d = 4;
8 swap(&c, &d);
9 return 0;
10 }
```
#### 2. Передать большой объект в функцию и не копировать его
```C
1 char str[] = "Hello";
2 int len = strlen(str);
```

#### 3. Оптимизация кода
```C
// Не оптимизированный код
int strlen(char *ptr){
	int len = 0;
	while (ptr[len] != '\0')
		++len;
	return len;
}
```
>**ptr[len] -> *(ptr + len)**
>Соответсвенно, в данной реализации будет 2n операций сложений

```C
// Не оптимизированный код
int strlen(char *ptr){
	char* p;
	while (*p != '\0')
		++p;
	return p - ptr;
}
```
>Здесь уже будет n + 1 арифметических операций 

### Ключевое слово const
**Константы** — фиксированные величины, которые не изменяются во время выполнения программы. Эти фиксированные величины также называются **литералами**.

#### const у переменной 
```C
const float pi = 3.14159
```
- Компилятор проверит, чтобы мы не изменили число pi.
- Дает больше информации программисту, читающему или используещему этот код.

```C
void print_hex(const int a){
	printf("%x", a);
}
```
> Программист подчеркнул, что функция не изменит параметр внутри себя

#### const у указателя
const защищает то, что **перед** ним.
```C
1 char s1[] = "hello";
2 char s2[] = "bye";
3 char const * p1 = s1;
4 p1[0] = 'a'; // compilation error
5 p1 = s2; // ok
6 char * const p2 = s1;
7 p2[0] = 'a'; // ok
8 p2 = s2; // compilation error
9 char const * const p3 = s1;
Но можно и так:
1 const char * p1; // equal to char const * p1;
```

## 3. Три вида памяти. Работа с кучей на C.
### Стек (stack)
- Локальные переменные функций, параметры функций.
- Код для выделения и освобождения генерирует компилятор.
- Выделяется при "входе" в функцию, освобождается при "выходе" из функции.
```C
1 int sum(int a, int b) {
2 int s = a + b;
3 return s;
4 }
5 int main() {
6 int c = 1; int d = 2;
7 int e = sum(c, d);
8 return 0;
9 }
```

Stack, растет вниз ↓(например, 10 Mb)
| **Кадр main** |**c, d, e, RV, RA**  |
|---------------|---------------------|
| **Кадр sum** | **a, c, s, RV, RA**  |
- RV - return value (возвращаемое значение)
- RA - return adsress (на какой адрес вернуться в main после окончания sum)

#### Вычислительная сложность
Вошли в функцию — выделили кадр (frame), вышли из функции — освободили кадр
- В процессоре есть регистр (например, sp), который хранит адрес “головы” стека
- Выделение кадра — уменьшение регистра на размер кадра, освобождение — увеличение (быстрые операции)
- Код, который расчитывает размер кадра и меняет sp, генерирует компилятор
- Выделение локальной переменной — это очень быстро, происходит один раз на функцию

#### Проблемы рекурсии
- Возможно большое кол-во вызовов, что приведет к переполнению стека.
- Зачастую можно переписать циклом без потери красоты решения.

### Глобальная/статическая память (static variables)
- Глобальные переменные (вне функций), статические переменные (static)
- Код для выделение и освобождения генерируется компилятором.
- Выделяется при загрузке в память, освобождается при завершении программы.
- Глобальные инициализируются в каком-то (неизвестном) порядке, статические при заходе в функцию.

Слово static имеет два разных смысла в зависимости от контекста.
```C
1 int a = 0; // Глобальная переменная (видна во всех файлах)
2
3 static int b = 0; // Глобальная переменная
4 // (видна только в этом файле)
5 void f() {
6 static int c = 0; // Статическая переменная
7 // (видна только в функции)
8 }
```
- К переменной a можно обращаться из других файлов при помощи extern.
- Переменная b не будет видна из других файлов даже если есть extern.
- Переменную c вообще не имеет смысла видеть в других файлах.

#### Глобальные переменные. Несколько файлов
```C
  1.h
1 extern int last_rnd;

  1.cpp
1 int last_rnd = 0; //выделение памяти
2 void srand() {
3 last_rnd = time(); //текущее время
4 }

  2.cpp
1 #include "1.h"
2 //extern -> выделение памяти происходит в другом месте
3 // (также знаем тип переменной)
4 int rand() {
5 last_rnd = (lst_rnd * 13 + 113) % 43;
6 return last_rnd;
7 }
```
>Данный код не скомпилируется, т.к. переменная определена дважды
> ```C
>   1.cpp
> 1 int last_rnd = 0;
> 2 void srand() {
> 3 last_rnd = time(); //текущее время
> 4 }
> 
>   2.cpp
> 1 int last_rnd = 0;
> 2 int rand() {
> 3 last_rnd = (lst_rnd * 13 + 113) % 43;
> 4 return last_rnd;
> 5 }
> ```

#### Вычислительная сложность
- В заголовке двоичного исполняемого файла написано, сколько static variables ему требуется
- Память выделяется “непрерывным куском”при загрузке программы. Освобождается — когда программа заканчивает работу.
- Выделение происходит быстро.

#### Почему лучше избегать глобальных переменных
- Потенциальный конфликт имен (несколько программистов в
разных файлах назвали разные переменные одинаково —>
конфликт на линковке)
- Трудно анализировать программу (сложнее следить за всеми
участками кода, в которых меняется перменная)
- Неизвестно, в каком порядке инициализируются разные файлы:
```C
1 // a.cpp
2 int ten = 10; // Первый, потому что константа
3 int x = ten; // Второй или третий
4 int foo() { return x; }

5 // b.cpp
6 int y = foo(); // Второй или третий
```
### Куча (heap)
- Код для выделения и освобождения пишет программист

Область памяти, в которой можно хранить различные данные. Главной особенностью является то, что управляет этой областью сам программист, а не компилятор.

```C
1 #include <stdlib.h>
2
3 int *p = malloc(1000000 * sizeof(int));
4 if (p == NULL){ // NULL в C, nullptr в C++. Старый код - 0.
5 /* not enough memory */
6 }
7 // if (!p) { ... } // Альтернативный вариант
8 p[0] = 1; p[13000] = 42;
9 ...
10 free(p);
```

- Временем жизни управляет программист
- Функция malloc обращается к операционной системе с просьбой выделить место (“непрерывный кусок”) в куче и, если ОС выделяет это место, возвращает укзатель на начало области (иначе — 0).
- Функция free освобождает память
- Нет ограничений по размеру как у стека и глобальных переменных (ограничена размером свободной памяти)

#### Отличия от стека и глобальных переменных
- Размер массива выясняется во время выполнения (ввел
пользователь, считали из файла)
- На стеке и у глобальных переменных размер должен быть
известен во время компиляции

#### Возможные ошибки
```C
1 int *p = (int *)malloc(1000000 * sizeof(int));
2 p = (int *)malloc(1000000 * sizeof(int));
3 // Или: p = NULL;
```
- Утечка памяти (memory leak): теперь память из первой строки
невозможно освободить (мы потеряли адрес)
- Такие ошибки можно искать утилитой valgrind
Вопрос! В современных ОС вся память, выделенная программой, после ее завершения возвращается системе (даже если была утечка). Зачем бороться с утечками?
1. Сервер (работает без перезапуска). Утечка при каждом запросе пользователя.
2.  Сначала все замедлится (файл подкачки), потом ОС аварийно завершит процесс.

#### Вычислительная сложность
**malloc должен:**
1.  Пройти по списку (одна из возможным реализаций) выделенных
областей
2. Найти непрерывную область нужного размера
Это *гораздо дольше* чем на стеке и у глобальных переменных!

#### Еще методы работы с кучей
- **calloc** — выделяет память и инициализирует ее нулями
- **realloc** — изменяет размер уже существующего массива.

Существует три результата работы функции:
1. если нужное число байт не занято в смежной области, то увеличивает область для массива
2. если рядом нет свободной памяти, перенесет массив в другое место
3. если вообще нет памяти под увеличенный массив, вернет 0

### void* 
По своей сути это указатель на любой тип данных. Т.к. void не имеет размерности, то с ним не будет работать арифметика указателей. Такой указатель всегда нужно приводить к какому-то классическому типу. 
```C
1 void qsort(void* array, size_t n, ...);
2
3 product_t array1[100];
4 int arrray2[20];
5 qsort(array1, 100, ...);
6 qsort(array2, 20, ...)
```
- void* — не работает адресная арифметика
- В С++ требуется явное приведение типов (в С можно неявно)
- void* malloc(...) (malloc возвращает void* )

## 4 и 5. Структуры. Неинтрузивный связный список на C. Интрузивный связный список на C
### Синтаксис структур. Применение 
Сущность описывается набором переменных: точка в 3D, товар в программе автоматизации на складе (название, вес, количество, ...) и т.д.
```C
1 struct product_s {
2 	char label[256];
3 	float weight;
4 	unsigned int price;
5 };
6
7 struct product_s p = { "Milk", 100, 5 }; //Инициализация
8 
9 scanf("%s %f %d", p.label, &(p.weight), &(p.price));
10
11 struct product_s array[100];
12 array[0].weight = 42;
13
14 struct product_s* ptr = malloc(sizeof(struct product_s));
15 ptr->weight = 42;
```
Структуры полностью копируются (оператор = требует линейное время)
Тонкость: при копирвании указателя будет скопировано значение указателя, а не данные, на которые он ссылается.

```C
1 struct product_s a, b;
2 scanf("%s%f%d", a.label, &a.weight, &a.price);
3 b = a; // Полностью копирует все поля, даже массивы.
4 a.price += 10;
5 printf("%d %d\n", a.price, b.price); // Разные значения.
```
```C
1 struct array_s {
2 int* p;
3 int n;
4 };
5 struct array_s a, b;
6 a.p = malloc(sizeof(int) * 100);
7 a.n = 100;
8 b = a; a.p[0] = 42;
9 printf("%d %d", a.p[0], b.p[0]); // Одинаковые значения
```
Особенность: в C/C++ структуры можно размещать на стеке, в глобальной памяти и на куче (malloc). В то время как в Python и Java только на куче.

Структуры можно передавать в функции в качестве параметров через стек. В таком случае нам придется скопировать на стек sizeof(product_s) байт для параметра функции и столько же для возвращаемого значения. Это может быть очень долго. Если в функции идейно не требуется копия стурктуры, то следует передать структуру через указатель.
 - Указатель всегда занимает одно и то же число байт вне зависимости от типа переменной, на которую указывает.
- Указатель позволяет менять значение (для структур — значение полей) переданной переменной.
### typedef
**typedef** - вводит новое имя (синоним) для существующего типа.
```C
1 typedef struct product_s product_t; //псевдоним
2 product_t p; // меньше букв
```
> size_t — тип переменной, которая содержит размер любой сущности в памяти (например, может быть определен как typedef unsigned long size_t).

Главное отличие от *define* в том, что *typedef* выполняется компилятором, который выяснил типы индентификаторов перед подстановкой (*typedef*применится только к типам, define к любому индетификатору)

### Неинтрузивный и интрузивный связный список
*<добавить картинку>*

Иногда нам может потребоваться структура, которая хранит в себе элементы и не ограничена константным размером. Мы хотим, чтобы структура динамически росал. Есть два варианта: *vector* или *связный список*

#### Какими методами обладает связный список
- Размер увеличивается при добавлении элементов.
- - Каждый элемент выделяется с помощью malloc 
- - Элементы расположены на произвольных адресах (в векторе - последовательно).
- - Каждый элемент хранит адреса последующего и предыдущего.
- Функции для создания и удаления
- Функции добавления элемента
- Функции для вывода на экран
- Функции для обращения элементам
- Функции вставки и удаления элементов
- - Из-за того что элементы расположены непоследовательно, не требуется смещать все остальные элементы
#### Различия между между вектором и связным списком
1. Т.к. в векторе элементы расположены последовательно, то найти i-ый элемент не составляет трудности. В то время как в связном списке придется шагать по адресам, что гораздо дольше.
2. Т.к. в векторе элементы расоложены последовательно, то добавление или удаление одного жлемента приведет к свдигу всех остльных, что очень затратно. В то время как в связном списке для подобных операций достаточно обновить указатели соседних элментво - очень быстро.

#### Различия интрузивного и неинтрузивного связного списка
В данном случае слово интрузивнй означет подход к связи данных и списка. 
В **неинтрузивном** связаном списке элемент структуры *данные* хранится в структуре *элменте списка*.
В **интрузивном** связном списке структура *элемент списка* хранится в в элементе структуры *данные*

*Иинтрузивный* список позволяет решить проблему двух malloc. В *неинтрузивном* списке, если наши данные представлены какой-либо структурой, то под них придется выделять память при создании *элемента списка*, при этом необходимо будет создать и сам *элемент списка*. 

## 6. Функции. Указатели на функции
### Как вызывается функция 
При компиляции в объектном файле остаются места с названием функций, без указания как их вызвать. Дальше проходит линкер и заменяет каждое название функции на адрес ее реализации. При вызове функции выделяется кадр на стеке, в котором выделяетс память под все параметры функции, а также под возвращаемое значение и адрес возврата. 
### Реализация сортировки
Идея: Разделяем массив на две части. Делим пока не дойдем до элементарных частей (размер кусочков равен 1 или 0). Дальше сливаем кусочки друг с другом. Слияние: сравниваем поэлементно два массива, вначале записываем меньший(больший) элемент, затем продолжаем сраванивать и записывать. Как только закончится один из массивов, записываем до конца оставшиеся элементы второго массива. 

1.  Если в рассматриваемом массиве один элемент, то он уже отсортирован — алгоритм завершает работу.
2.  Иначе массив разбивается на две части, которые сортируются рекурсивно.
3.  После сортировки двух частей массива к ним применяется процедура слияния, которая по двум отсортированным частям получает исходный отсортированный массив.

Универсальность добивается за счет того, что в качестве параметра передается размер в байтах сортируемых элементов. В самой реализации все работает через char*, т.к. sizeof(char) = 1 байт, следовательно, им просто удобно итерироваться с помощью адресной арифметики. 
Элементы меняются местами побайтово. Чтобы перезаписать какой-либо элемент из одного массива в другой, необходимо перенести отдельно каждый байт этого элемента на новое место.

```C
int  merge(
size_t element_size, 
char* left,
char* mid,
char* right,
int  (*comparator)(const  void*, const  void*))  {
	 size_t i = 0, j = 0;
	 size_t elements = (right - left) / element_size;
	 char* result = malloc(elements * element_size);
	 if  (result == NULL) {
		 return  -1;
	 }
	 while  (left + i * element_size < mid && mid + j * element_size < right) {
		 if  (comparator(left + i * element_size, mid + j * element_size) < 0) {
			 for  (size_t k = 0; k < element_size; k++)
				 *(result + k + (i + j) * element_size)  = *(left + k + i * element_size);
			 i++;
		 }
		 else {
			 for  (size_t k = 0; k < element_size; k++)
				 *(result + k + (i + j) * element_size) = *(mid + k + j * element_size);
			 j++;
		 }
	 }
	 while  (left + i * element_size < mid) {
		 for  (size_t k = 0; k < element_size; k++)
			 *(result + k + (i + j) * element_size)  = *(left + k + i * element_size);
		 i++;
	 }
	 while  (mid + j * element_size < right) {
		 for  (size_t k = 0; k < element_size; k++)
			 *(result + k + (i + j) * element_size)  = *(mid + k + j * element_size);
		 j++;
	 }
	 for  (size_t l = 0; l < i + j; l++) {
		 for  (size_t k = 0; k < element_size; k++) {
			 *(left + k + l * element_size)  = *(result + k + l * element_size);
		 }
	 }
	 free(result);
	 return  0;
	}
int  mergesort(
	 void* array,
	 size_t elements, size_t element_size,
	 int  (*comparator)(const  void*, const  void*))  {
	 int status;
	 char* arr = array;
	 size_t m = elements / 2;
	 if  (elements <= 1)
		 return  0;
	 status = mergesort(arr, m, element_size, comparator);
	 status = mergesort(arr + m * element_size, elements - m, element_size, comparator);
	 if  (status == -1)
		 return  -1;
	 char* left = arr;
	 char* mid = arr + (elements / 2) * element_size;
	 char* right = arr + elements * element_size;
	 if  (merge(element_size, left, mid, right, comparator) == -1)
		 return  -1;
	 return  0;
}
```

## 7. Обзор стандартной библиотеки C
### string.h - работа со строками и массивами 

**memcpy** - функция копирует n байт из массива (области памяти), на который указывает аргумент source, в массив (область памяти), на который указывает аргумент destination. Если массивы перекрываются, результат копирования будет не определен.
>```C 
>void *memcpy (void *destination, const void *source, size_t n);
>```

**memcmp** - функция сравнивает первые count символов массивов, на которые указывают buf1 и buf2. Сравнение производится лексикографически. Функция memcmp() возвращает целое число, которое интерпретируется, как указано ниже:
>```C 
>int memcmp(const void *_buf1_, const void *_buf2_, size_t _count_);
>```

Функция memcmp() возвращает целое значение, которое интерпретируется следующим образом.
| Число | Значение              |
|-------|-----------------------|
| < 0   | buf1 меньше, чем buf2 |
| 0     | buf1 равен buf2       |
| > 0   | buf1 больше, чем buf2 |

**strcpy** - аналог *memcpy* только работает на строки
>```C 
>char* strcpy (char * destptr, const char * srcptr );
>```

**strcmp** - аналог *memcmp* только работает со строками
>```C 
> int strcmp (const char *s1, const char *s2);
>```

**strcat** - функция добавляет в строку, на которую указывает аргумент destination, строку, на которую указывает аргумент append. Символ конца строки помещается в конце объединенных строк.

Следует иметь в виду, что функция не производит проверки границ, поэтому программист должен сам позаботиться о том, чтобы строка str1 была достаточно длинной и могла вместить помимо своего первоначального содержания еще и содержание строки str2.
>```C 
> char *strcat (char *destination, const char *append);
>```

**strstr** - функция ищет первое вхождение строки (за исключением признак конца строки), на которую указывает аргумент strA, в строку , на которую указывает аргумент strB. Если строка strA имеет нулевую длину, то функция вернет указатель на начало строки strB.
>```C 
> char *strstr(const char *strB, const char *strA);
>```

**strchr** - функция ищет первое вхождения символа, код которого указан в аргументе ch, в строке, на которую указывает аргумент str.
>```C 
> char *strchr (const char *str, int ch);
>```

**strtok** - функция выделяет очередную часть строки, на которую указывает аргумент str, отделенную одним из символов разделителей указанных в строке, на которую указывает аргумент sep. Последовательный вызов функции strtok приводит к разбиению строки str на части (лексемы).
>```C 
> char *strtok(char *str, const char *sep);
>``` 

### stdlib.h - работа с памятью, алгоритмами 
**atoi** - aункция конвертирует строку, на которую указывает параметр str, в величину типа int. Строка должна содержать корректную запись целого числа. В противном случае возвращается 0.
>```C 
> int atoi(const char *str)
>``` 

**strtol** - функция преобразует строковое представление числа, которое содержится в строке, адресуемой параметром-указателем *start*, в значение типа *long int* и возвращает полученный результат. Основание системы счисления, в которой представлено преобразуемое число, определяется параметром *radix*.
>```C 
> long int strtol(const char *_start_, char **_end_, int _radix_);
>``` 

**srand/rand** - Функция *srand()* используется для установки начала последовательности, генерируемой функ­цией *rand()* (функция *rand()* возвращает псевдослучайные числа).
>```C 
> void srand(unsigned seed);
> int rand(void);
>``` 

**qsort** - Функция qsort() сортирует массив, на который указывает параметр base, используя quicksort — алгоритм сортировки широкого назначения, разработанный С. Р. Хори. После завершения фун­кции массив становится отсортированным. Параметр num задает число элементов массива, пара­метр size задает размер в байтах каждого элемента.
>```C 
>void qsort(void *base, size_t num, size_t size, int (*compare) (const void *, const void *));
>``` 

>Функция, на которую указывает параметр compare, сравнивает элементы массива с ключом. Формат функции compare следующий:  
>```C 
> int func_name(const void *arg1, const void *arg2);
>``` 

## 8 и 9. Ввод-вывод на C. Текстовые файлы. Бинарные файлы
**FILE** - этот тип данных определяет поток и содержит информацию, необходимую для управления потоком, в том числе указатель на буфер потока, и его показатели состояния.

При подключении заголовочного файла `<stdio.h>` в проект, автоматически создаются три объекта типа `FILE*`, потоки ввода/вывода и стандартный поток ошибок. К этим потокам можно обратиться через указатели `stdin`, `stdout` и `stderr`.

**fopen** - функция fopen() открывает файл, имя которого указано аргументом fname, и возвращает свя­занный с ним указатель. Тип операций, разрешенных над файлом, определяется аргументом mode.
| Режим | Значение |
|--|--|
| "r" | Открывает файл для чтения (по умолчанию файл открывается как текстовый). |
| "w" | Создает файл для записи (по умолчанию файл открывается как текстовый). |
| "rb / rw" | Работа с бинарными фалйми |
| "rt / wt" | Работа с текстовыми файлами |

**fclose** - функция fclose() используется для закрытия потока, ранее открытого с помощью fopen(). Она сохраняет в файл данные, находящиеся в дисковом буфере, и выполняет операцию системного уровня по закрытию файла. Вызов fclose() освобождает блок управления файлом, связанный с потоком, и делает его доступным для повторного использования.

Стандарт Си определяет три вида буферизации потоков:

-   _Небуферизированные_  потоки (_unbuffered_) — буферизации на стороне программы/libc как таковой нет: все данные по возможности сразу передаются ОС/устройству.
-   _Полностью буферизированные_  (_fully buffered_) — данные записываются в буфер и будут фактически выведены только при его заполнении или при его принудительном сбросе.
-   _Линейно-буферизированные_  (_line buffered_) — данные буферизируются, но выводятся, если в потоке встретится символ конца строки (`\n`), если буфер будет полностью заполнен или принудительно сброшен. Также все  _линейно-буферизированные_  потоки вывода (в частности  `stdout`) сбрасываются, когда какой-либо (обычно другой, например,  `stdin`)  _линейно-буферизированный_  поток пытается что-либо прочитать, а его буфер ввода пуст.

**printf** - Функция printf() записывает в stdout аргументы из списка arg-list под управлением строки, на которую указывает аргумент format.

**fprintf** - Функция fprintf() выводит значения аргументов, составляющих список arg-list, в формате, указан­ном в строке format, в поток, на который указывает srtream. Возвращаемая величина — это число действительно выведенных символов. В случае ошибки возвращается отрицательное значение.

**scanf** - Функция scanf() является процедурой ввода общего назначения, считывающей данные из пото­ка stdin. Она может считывать данные всех базовых типов и автоматически конвертировать их в нужный внутренний формат. Если бы printf() выполняла ввод, а не вывод, ее можно было бы назвать аналогом scanf().

**fscanf** - Функция fscanf() работает точно так же, как функция scanf(), за исключением того, что она считывает информацию из потока, указанного аргументом stream, а не из stdin.

**sprintf** - Функция sprintf() идентична printf(), за исключением того, что вывод производится в массив, указанный аргументом buf.

**sscanf** - Функция sscanf() идентична функции scanf() во всем, кроме того, что данные считываются из массива, указанного аргументом buf, а не из файла stdin.

**fgets** - Функция fgets() считывает до num-1 символов из файла stream и помещает их в массив символов, на который указывает str. Символы считываются до тех пор, пока не встретится символ «новая строка», EOF или до достижения указанного предела. По окончании считывания в массив str сразу после последнего считанного символа помещается нулевой символ. Символ «новая строка» при считывании будет сохранен и станет частью массива str.

### Обработка ошибок
```C
1 while(!feof(fin)) {
2 	fread(...)
3 	if(ferror(fin)) {
4 	...
5 	}	
6 }
```
- **feof** возвращает индикатор конца файла  
Макросом feof() контролируется указатель положения в файле — для того, чтобы установить, достигнут ли конец файла, связанный с потоком stream. Если указатель положения в файле нахо­дится в конце файла, то возвращается ненулевое значение; в противном случае возвращается нуль.
- **ferror** - возвращает индикатор ошибки
Функция ferror() проверяет, имеются ли файловые ошибки в данном потоке stream. Возврат 0 означает отсутствие ошибок, а ненулевая величина указывает на наличие ошибки.

Сначала fread перейдет чтением «за конец файла», а потом установит индикатор (не заранее).
ferror, feof — была ли при последней операции с файлом получена ошибка/достигнут конец файла.

**fread** - Функция fread() считывает count объектов — каждый объект по size символов в длину — из потока, указанного stream, и помещает их в символьный массив, указанный в buf. Указатель пози­ции в файле продвигается вперед на количество считанных символов.

**fwrite** - Функция fwrite() записывает count объектов — каждый объект по size символов в длину — в поток, указанный stream, из символьного массива, указанного buf. Указатель позиции в файле продвигается вперед на количество записанных символов.

**fseek** - переместиться на заданную позицию в файле (удобно пропускать ненужные поля в заголовке бинарного файла). Функция fseek() устанавливает указатель положения в файле, связанном со stream, в соответ­ствии со значениями offset и origin. Ее основное назначение — поддерживать операции ввода/ вывода по произвольному адресу. Аргумент offset — это выраженный в байтах сдвиг от позиции, определяемой origin, до новой позиции. Аргумент origin может принимать значения 0, 1 или 2, причем 0 означает начало файла, 1 — текущую позицию, а 2 — конец файла.

**ftell** - возвращает текующую позицию. Функция ftell() возвращает текущее значение указателя положения в файле для указанного потока. Это значение представляет собой количество байт, на которое указатель отстоит от начала файла.

**fflush** - Если stream связан с файлом, открытым для записи, то вызов fflush() приводит к физической записи содержимого буфера в файл. Если же stream указывает на вводимый файл, то очищается входной буфер. В обоих случаях файл остается открытым.

## 10. Ключевые слова `extern`, `static`, `inline`

### `extern` у переменных
Поскольку С позволяет выполнять раздельную компиляцию модулей для большой программы в целях ускорения компиляции и помощи управлению большими проектами, должны быть способы передачи информации о глобальных переменных файлам программы. Решение заключается в объявлении всех глобальных переменных в одном файле и использовании при объявлении в других файлах слова extern

Если при объявлении выделяется память под переменную, то процесс называется определением. Использование extern приводит к объявлению, но не к определению. Оно просто говорит компилятору, что определение происходит где-то в другом месте программы.

```C
  1.h
1 extern int last_rnd;

  1.cpp
1 int last_rnd = 0; //выделение памяти
2 void srand() {
3 last_rnd = time(); //текущее время
4 }

  2.cpp
1 #include "1.h"
2 //extern -> выделение памяти происходит в другом месте
3 // (также знаем тип переменной)
4 int rand() {
5 last_rnd = (lst_rnd * 13 + 113) % 43;
6 return last_rnd;
7 }
```

## `static` у переменных и функций
```C
1 void f() {
	// сохраняет значение между вызовами функции
2 static int call_count = 0; //инициализируется один раз
3 ...
4 printf("Called times: %d", call_count);
5 call_count++;
6 }
7
8 int main() {
9 f(); f(); f();
10 }
```

Слово static имеет два разных смысла в зависимости от контекста.
```C
1 int a = 0; // Глобальная переменная (видна во всех файлах)
2
3 static int b = 0; // Глобальная переменная
4 // (видна только в этом файле)
5 void f() {
6 static int c = 0; // Статическая переменная
7 // (видна только в функции)
8 }
```
- К переменной a можно обращаться из других файлов при помощи extern.
- Переменная b не будет видна из других файлов даже если есть extern.
- Переменную c вообще не имеет смысла видеть в других файлах.

**static** у глобальной переменной или функции — идентификатор используется только для разрешения имен в рамках одного файла
```C
1 //tree.c
2 static tree_t node;
3 static void fill_nodes() { tree_t t; ... }
4 //list.c
5 static list_t node;
6 static void fill_nodes() { list_t l;... }
```
В ELF файл попадут обе функции.

## `inline` у функций
“Заинлайнить” — оптимизация компилятора.


```C
// До:
1 int max(int a, int b) {
2 if(a > b)
3 return a;
4 else
5 return b;
6 }
7 main( ) {
8 int c = ...;
9 int b = ...;
10 int d = max(c, b);
11 }
```

```C
// После:
1 main( ) {
2 int c = ...;
3 int b = ...;
4 if(c > b)
5 d = c;
6 else
7 d = b;
8
9 }
```
Компилятор принимает такие решения самостоятельно. Можно дать совет -O0, -O1, -O2, -O3 (уровень оптимизации).
```C
  a.c
1 int max(int a, int b) {
2 if(a > b)
3 return a;
4 else
5 return b;
6 }
  b.c
1 f( ) {
2 int c = ...;
3 int b = ...;
4 int d = max(c, b);
5 }
```
>Такой код заинлайнить нельзя, потому что на стадии компиляции определение функции max недоступно при компиляции b.c

```C
  a.h
1 int max(int a, int b) {
2 if(a > b)
3 return a;
4 else
5 return b;
6 }
  b.c
1 #include "a.h"
2 f( ) { int c = ...; int b = ...; int d = max(c, b); }
  c.c
1 #include "a.h"
2 g( ) { int e = ...; int f = ...; int g = max(e, f); }
```
> Заинлайнится, но будет ошибка double definition на линковке.

```C
  a.h
1 inline int max(int a, int b) {
2 if(a > b)
3 return a;
4 else
5 return b;
6 }
  b.c
1 #include "a.h"
2 f( ) { int c = ...; int b = ...; int d = max(c, b); }
  c.c
1 #include "a.h"
2 g( ) { int c = ...; int b = ...; int d = max(c, b); }
```
>Линкер выберет один какой-то вариант функции. В ELF файл попадет одна функция.

## Разное :)
### ключевое слово `const`
**Константы** — фиксированные величины, которые не изменяются во время выполнения программы. Эти фиксированные величины также называются **литералами**.

#### const у переменной 
```C
const float pi = 3.14159
```
- Компилятор проверит, чтобы мы не изменили число pi.
- Дает больше информации программисту, читающему или используещему этот код.

```C
void print_hex(const int a){
	printf("%x", a);
}
```
> Программист подчеркнул, что функция не изменит параметр внутри себя

#### const у указателя
const защищает то, что **перед** ним.
```C
1 char s1[] = "hello";
2 char s2[] = "bye";
3 char const * p1 = s1;
4 p1[0] = 'a'; // compilation error
5 p1 = s2; // ok
6 char * const p2 = s1;
7 p2[0] = 'a'; // ok
8 p2 = s2; // compilation error
9 char const * const p3 = s1;
Но можно и так:
1 const char * p1; // equal to char const * p1;
```

### Функции с переменным числом параметров
```C
  va_start, va_arg, va_end — макросы.
1 void simple_printf(const char* fmt, ...) {
2 va_list args;
3 //записать в args адрес следующего за fmt параметра на стеке
4 va_start(args, fmt);
5 while(*fmt != '\0') {
6 if(*fmt=='d') {
7 //достать со стека переменную типа int
8 int i = va_arg(args, int)
9 // здесь должен быть код, который
10 // выводит int на экран с помощью putc
11 }
12 fmt++;
13 }
14 va_end(args);
15 }
16 //Труднообнаруживаемые ошибки
17 printf("%s", 5);
18 printf("%d %d", 4); printf("%d", 4, 5);
```

### Библиотеки
**Статические** (*.a, *.lib): объектные файла из библиотеки присоеднияются к программе в момент линковки.
- Легко установить (не нужно отдельно загружать библиотеку)
- При выходе новой версии библиотеки (например, исправлен баг) автору программы нужно послать пользователю пересобранную версию

**Динамические** (*.so, *.dll): хранятся отдельно, связывание программы и библиотеки происходит в момент выполнения (помогает отдельная компонента — загрузчик).
- Необходимо отдельно установить все необходимые библиотеки (решение: packages and repositories)
- При выходе новой версии библиотеки (например, исправлен баг) пользователь может самостоятельно обновить только библиотеку без пересборки программы.

Для использования библиотеки нужно: *.a или *.so и заголовочные файлы
Ключи:
- имя библиотеки (-lexpat)
- static сборка со статической версией библиотеки (по умолчанию динамическая)

Еще бывает загрузка динамической библиотеки по запросу (плагины)
```C
void *dlopen(const char *library_name, int flags);
```
